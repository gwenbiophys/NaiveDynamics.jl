<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developer Diary · NaiveDynamics.jl</title><meta name="title" content="Developer Diary · NaiveDynamics.jl"/><meta property="og:title" content="Developer Diary · NaiveDynamics.jl"/><meta property="twitter:title" content="Developer Diary · NaiveDynamics.jl"/><meta name="description" content="Documentation for NaiveDynamics.jl."/><meta property="og:description" content="Documentation for NaiveDynamics.jl."/><meta property="twitter:description" content="Documentation for NaiveDynamics.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">NaiveDynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Index</a></li><li class="is-active"><a class="tocitem" href>Developer Diary</a><ul class="internal"><li><a class="tocitem" href="#1.-Let&#39;s-document-27-April"><span>1. Let&#39;s document - 27 April</span></a></li><li><a class="tocitem" href="#2.-3-May-packaging-packages-locally"><span>2. 3 May - packaging packages locally</span></a></li></ul></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Developer Diary</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Developer Diary</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gwenbiophys/NaiveDynamics.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gwenbiophys/NaiveDynamics.jl/blob/main/docs/src/devdiary.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Developer-Diary"><a class="docs-heading-anchor" href="#Developer-Diary">Developer Diary</a><a id="Developer-Diary-1"></a><a class="docs-heading-anchor-permalink" href="#Developer-Diary" title="Permalink"></a></h1><h2 id="1.-Let&#39;s-document-27-April"><a class="docs-heading-anchor" href="#1.-Let&#39;s-document-27-April">1. Let&#39;s document - 27 April</a><a id="1.-Let&#39;s-document-27-April-1"></a><a class="docs-heading-anchor-permalink" href="#1.-Let&#39;s-document-27-April" title="Permalink"></a></h2><p>Today has been an interesting day. I have been working on my baseline code but really hardening my documentation so that I have a well collected space to start hucking my thoughts. </p><p>For instance, I added CSV and NamedArrays .jl to prepare for testing on whether the </p><pre><code class="language-julia hljs">mutable struct GenericObjectCollection &lt;: ObjectCollection 
    name::AbstractArray{String, 1}

    position::AbstractArray{AbstractFloat, 3}
    velocity::AbstractArray{AbstractFloat, 3}

    uniqueID::AbstractArray{UUID,1}

end</code></pre><p>makes any sense, or if I should place all this information into a single array. And then I could test how this version of GenericObjectCollection scales, comparing it against a NamedArray convention. The primary point is to minimize processing time on putting these arrays together, while keeping my function accesses to data meaningful. I do not want the following:</p><pre><code class="language-julia hljs">Collection = [AbstractArray{String, 1}, AbstractArray{AbstractFloat, 3}, AbstractArray{AbstractFloat, 3}]
function do_something(Collection)
    return Collection[1] - Collection[2]
end</code></pre><p>in which function writing depends on making sure I have the right index of my Collection, so I don&#39;t do something stupid, like add a force term to a velocity term. I admit, something like <code>position = Collection[3]</code> is reallly easy, but we are here for overengineered solutions. ;)</p><p>But then my julia package would not precompile! Because I added new packages without updating the project.toml, so I had to relearn how to add new dependencies to a package.</p><p>It has been an hour and I still haven&#39;t figured out how to automatically get docstrings for functions passed into an index/api page, like they have it over at Molly.jl. Oh well, it is likely far better to get the gh-pages version of the documentation working.</p><h2 id="2.-3-May-packaging-packages-locally"><a class="docs-heading-anchor" href="#2.-3-May-packaging-packages-locally">2. 3 May - packaging packages locally</a><a id="2.-3-May-packaging-packages-locally-1"></a><a class="docs-heading-anchor-permalink" href="#2.-3-May-packaging-packages-locally" title="Permalink"></a></h2><p>in order to point a test file to my development package and skipall the githubbing and comppiling, i must</p><pre><code class="language-julia hljs">pgk() dev ./NaiveDynamics.jl
using Revise
using NaiveDynamics</code></pre><p>in that specific order. That way a change can be made in the development-source, and immediately referenced in the test/user file. Thank you very much, Revise.jl/stable. To hell with you, Copilot.</p><h3 id="Let&#39;s-talk-about-DataFrame-ification"><a class="docs-heading-anchor" href="#Let&#39;s-talk-about-DataFrame-ification">Let&#39;s talk about DataFrame-ification</a><a id="Let&#39;s-talk-about-DataFrame-ification-1"></a><a class="docs-heading-anchor-permalink" href="#Let&#39;s-talk-about-DataFrame-ification" title="Permalink"></a></h3><p>In the commits last weekend I was very focused on modifiying this package&#39;s structure so that a user, regardless of usecase, could design functions around their data in the <code>ObjectCollection</code> type WITHOUT relying on the order of set items in the type. In the current <code>collect_objects()</code> function, I have this nonsense:</p><pre><code class="language-julia hljs">    simCollection = GenericObjectCollection(
        fill(step_n, objectcount),
        fill(&quot;duck&quot;, objectcount),
        [1:objectcount;],
        [SizedVector{3, Float64}(rand(positionRange, 3)) for each in 1:objectcount],
        [SizedVector{3, Float64}(rand(velocityRange, 3)) for each in 1:objectcount],
        [SizedVector{3, Float64}(zeros(Float64, 3)) for each in 1:objectcount],
        )</code></pre><p>when I would prefer a semantics based method that does not depend on the order of inputs. After a lot of testing I just tossed in a big dataframe and a little dataframe. I ran a 1 step simulation of 100 000 atoms, and execution time took at least 3.7 seconds and processed through a humonculous 2GiB of data. I tweaked it a little, and then it wouldnt run anymore at all for OutOfMemory errors. So it became my new task to performance test again and again on all the different methods and packages I could find for multiplying two arrays by broadcasting. We got to a very good place with generating position vectors:</p><pre><code class="language-julia hljs">position = [MVector{3, Float64}(rand(posRange, 3)) for each in 1:5]</code></pre><p>and with performing the multiplication, as base.broadcast has no idea how to solve a vector of mutable vectors:</p><pre><code class="language-julia hljs">function posVel_multiply!(position, velocity)
    for i in 1:length(position)
        position[i] .*= velocity[i]
    end
    return position
end</code></pre><p>We had a path to de-dataframe-ification and a massive performance improvement. But we still had not solved the convenience problem, but ya know what? I&#39;m good with inconvenient. I have spent a long time trying to solve a problem that isn&#39;t a problem. I can winback my semantics with statements at the beginning of a function, like in simulate where we unwind the datatype hierarchy to pull the position array of arrays out of the &quot;system&quot; type. It&#39;s a less beautiful solution maybe, but no less effective.</p><p>And how much better is life? Sans parallelism and multithreading–just from algorithmic and datatype-selection improvements– we need to run the 100k simulation out to ~60 steps for it to take as long as the DataFrame&#39;s version. And we need to run at least 130 steps to generate as much information as the DataFrame&#39;s 1 step. Not that I blame the package&#39;s authors, it was a very silly idea to turn a highly versatile data processing tool into the DNA of the organism that forms this Naive package. </p><p>There are still algorithmic improvements to be made. I wanted to use a vector of mutable vectors, like this:</p><pre><code class="language-julia hljs">using StaticArrays
using Distributions

minposition = -5.0
maxposition = 5.0
posRange = Uniform(minposition, maxposition)
velRange = Uniform(minposition, maxposition)
position = [MVector{3, Float64}(rand(posRange, 3)) for each in 1:5]
velocity = [MVector{3, Float64}(rand(velRange, 3)) for each in 1:5]


function posVel_multiply!(position, velocity)
    for i in 1:length(position)
        position[i] .*= velocity[i]
    end
    return position
end

posVel_multiply!(position, velocity)</code></pre><p>but the posVel_multiply! does not work in the simulate!() function, and I have absolutely no clue why. It looks to be an active issue on github, and substituting the mutablevector with a sized vector solves the issue. But at low atoms counts, performance falls back by about 20%, and it balloons as count increases. At 100k atoms, it appears about 10x slower than a mutable vector, at about 3ms for the broadcasted multiplication alone. In context, the sized vector can only multiply the position and velocity vectors in about 50 ms per step, and this is an engine with zero interactions. </p><p>However the logging of the simulation actually takes longer than everything else under <code>simulate!()</code>, so there are several angles of optimization before we even consider threading or SIMD operations that the compiler doesn&#39;t already perform.</p><p>But for now we have an angle of approach a velocity verlet stepper that will help bring the time per step back up to &gt;1 second</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Index</a><a class="docs-footer-nextpage" href="../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.0 on <span class="colophon-date" title="Saturday 4 May 2024 07:01">Saturday 4 May 2024</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
