var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Order   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [NaiveDynamics]\nOrder   = [:module, :type, :constant, :function, :macro]","category":"page"},{"location":"api/#NaiveDynamics.GenericRandomCollector","page":"API","title":"NaiveDynamics.GenericRandomCollector","text":"Collector\n\nCollector super-type for simulation initialization.\n\n\n\n\n\n","category":"type"},{"location":"helpGwen/#Gwen's-Handy-Helpers","page":"Gwen's Handy Helpers","title":"Gwen's Handy Helpers","text":"","category":"section"},{"location":"helpGwen/#A-dirty-list-of-instructions-and-links-and-references","page":"Gwen's Handy Helpers","title":"A dirty list of instructions and links and references","text":"","category":"section"},{"location":"helpGwen/#add-a-new-package-to-a-dev-package's-source","page":"Gwen's Handy Helpers","title":"add a new package to a dev package's source","text":"","category":"section"},{"location":"helpGwen/","page":"Gwen's Handy Helpers","title":"Gwen's Handy Helpers","text":"pgk(activate NaiveDynamics.jl\n    add NewPackages\n)","category":"page"},{"location":"helpGwen/#getting-a-new-REPL-started-after-changing-a-type","page":"Gwen's Handy Helpers","title":"getting a new REPL started after changing a type","text":"","category":"section"},{"location":"helpGwen/","page":"Gwen's Handy Helpers","title":"Gwen's Handy Helpers","text":"I do believe using Revise is unnecessary, as VSCode supposedly already runs it. I havent noticed any issues, but I havent tested specifically if it works. Also, until I change the directory name, I must put NaiveDynamics.jl, not NaiveDynamics. That will mess life up!","category":"page"},{"location":"helpGwen/","page":"Gwen's Handy Helpers","title":"Gwen's Handy Helpers","text":"pgk() dev ./NaiveDynamics.jl\nusing Revise\nusing NaiveDynamics","category":"page"},{"location":"devdiary/#Developer-Diary","page":"Developer Diary","title":"Developer Diary","text":"","category":"section"},{"location":"devdiary/#1.-Let's-document-27-April","page":"Developer Diary","title":"1. Let's document - 27 April","text":"","category":"section"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"Today has been an interesting day. I have been working on my baseline code but really hardening my documentation so that I have a well collected space to start hucking my thoughts. ","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"For instance, I added CSV and NamedArrays .jl to prepare for testing on whether the ","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"mutable struct GenericObjectCollection <: ObjectCollection \n    name::AbstractArray{String, 1}\n\n    position::AbstractArray{AbstractFloat, 3}\n    velocity::AbstractArray{AbstractFloat, 3}\n\n    uniqueID::AbstractArray{UUID,1}\n\nend","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"makes any sense, or if I should place all this information into a single array. And then I could test how this version of GenericObjectCollection scales, comparing it against a NamedArray convention. The primary point is to minimize processing time on putting these arrays together, while keeping my function accesses to data meaningful. I do not want the following:","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"Collection = [AbstractArray{String, 1}, AbstractArray{AbstractFloat, 3}, AbstractArray{AbstractFloat, 3}]\nfunction do_something(Collection)\n    return Collection[1] - Collection[2]\nend","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"in which function writing depends on making sure I have the right index of my Collection, so I don't do something stupid, like add a force term to a velocity term. I admit, something like position = Collection[3] is reallly easy, but we are here for overengineered solutions. ;)","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"But then my julia package would not precompile! Because I added new packages without updating the project.toml, so I had to relearn how to add new dependencies to a package.","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"It has been an hour and I still haven't figured out how to automatically get docstrings for functions passed into an index/api page, like they have it over at Molly.jl. Oh well, it is likely far better to get the gh-pages version of the documentation working.","category":"page"},{"location":"devdiary/#2.-3-May-packaging-packages-locally","page":"Developer Diary","title":"2. 3 May - packaging packages locally","text":"","category":"section"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"in order to point a test file to my development package and skipall the githubbing and comppiling, i must","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"pgk() dev ./NaiveDynamics.jl\nusing Revise\nusing NaiveDynamics","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"in that specific order. That way a change can be made in the development-source, and immediately referenced in the test/user file. Thank you very much, Revise.jl/stable. To hell with you, Copilot.","category":"page"},{"location":"devdiary/#Let's-talk-about-DataFrame-ification","page":"Developer Diary","title":"Let's talk about DataFrame-ification","text":"","category":"section"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"In the commits last weekend I was very focused on modifiying this package's structure so that a user, regardless of usecase, could design functions around their data in the ObjectCollection type WITHOUT relying on the order of set items in the type. In the current collect_objects() function, I have this nonsense:","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"    simCollection = GenericObjectCollection(\n        fill(step_n, objectcount),\n        fill(\"duck\", objectcount),\n        [1:objectcount;],\n        [SizedVector{3, Float64}(rand(positionRange, 3)) for each in 1:objectcount],\n        [SizedVector{3, Float64}(rand(velocityRange, 3)) for each in 1:objectcount],\n        [SizedVector{3, Float64}(zeros(Float64, 3)) for each in 1:objectcount],\n        )","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"when I would prefer a semantics based method that does not depend on the order of inputs. After a lot of testing I just tossed in a big dataframe and a little dataframe. I ran a 1 step simulation of 100 000 atoms, and execution time took at least 3.7 seconds and processed through a humonculous 2GiB of data. I tweaked it a little, and then it wouldnt run anymore at all for OutOfMemory errors. So it became my new task to performance test again and again on all the different methods and packages I could find for multiplying two arrays by broadcasting. We got to a very good place with generating position vectors:","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"position = [MVector{3, Float64}(rand(posRange, 3)) for each in 1:5]","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"and with performing the multiplication, as base.broadcast has no idea how to solve a vector of mutable vectors:","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"function posVel_multiply!(position, velocity)\n    for i in eachindex(position)\n        position[i] .*= velocity[i]\n    end\n    return position\nend","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"We had a path to de-dataframe-ification and a massive performance improvement. But we still had not solved the convenience problem, but ya know what? I'm good with inconvenient. I have spent a long time trying to solve a problem that isn't a problem. I can winback my semantics with statements at the beginning of a function, like in simulate where we unwind the datatype hierarchy to pull the position array of arrays out of the \"system\" type. It's a less beautiful solution maybe, but no less effective.","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"And how much better is life? Sans parallelism and multithreading–just from algorithmic and datatype-selection improvements– we need to run the 100k simulation out to ~60 steps for it to take as long as the DataFrame's version. And we need to run at least 130 steps to generate as much information as the DataFrame's 1 step. Not that I blame the package's authors, it was a very silly idea to turn a highly versatile data processing tool into the DNA of the organism that forms this Naive package. ","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"There are still algorithmic improvements to be made. I wanted to use a vector of mutable vectors, like this:","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"using StaticArrays\nusing Distributions\n\nminposition = -5.0\nmaxposition = 5.0\nposRange = Uniform(minposition, maxposition)\nvelRange = Uniform(minposition, maxposition)\nposition = [MVector{3, Float64}(rand(posRange, 3)) for each in 1:5]\nvelocity = [MVector{3, Float64}(rand(velRange, 3)) for each in 1:5]\n\n\nfunction posVel_multiply!(position, velocity)\n    for i in eachindex(position)\n        position[i] .*= velocity[i]\n    end\n    return position\nend\n\nposVel_multiply!(position, velocity)","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"but the posVel_multiply! does not work in the simulate!() function, and I have absolutely no clue why. It looks to be an active issue on github, and substituting the mutablevector with a sized vector solves the issue. But at low atoms counts, performance falls back by about 20%, and it balloons as count increases. At 100k atoms, it appears about 10x slower than a mutable vector, at about 3ms for the broadcasted multiplication alone. In context, the sized vector can only multiply the position and velocity vectors in about 50 ms per step, and this is an engine with zero interactions. ","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"However the logging of the simulation actually takes longer than everything else under simulate!(), so there are several angles of optimization before we even consider threading or SIMD operations that the compiler doesn't already perform.","category":"page"},{"location":"devdiary/","page":"Developer Diary","title":"Developer Diary","text":"But for now we have an angle of approach a velocity verlet stepper that will help bring the time per step back up to >1 second","category":"page"},{"location":"","page":"Index","title":"Index","text":"../../README.md","category":"page"}]
}
